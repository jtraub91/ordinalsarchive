<div class="w-full py-2">
  <div class="relative h-6 my-2">
    <div class="absolute w-full h-1 top-1/2 -translate-y-1/2 bg-gray-300 dark:bg-lime-500 rounded-sm" id="background-track"></div>
    <div class="absolute h-1 top-1/2 -translate-y-1/2 bg-black dark:bg-pink-500 rounded-sm z-[5]" id="active-track"></div>
    <div class="absolute w-4 h-4 top-1/2 -translate-y-1/2 bg-white border-2 border-black dark:border-pink-500 dark:bg-black cursor-pointer z-10" id="start-handle"></div>
    <div class="absolute w-4 h-4 top-1/2 -translate-y-1/2 bg-white border-2 border-black dark:border-pink-500 dark:bg-black cursor-pointer z-10" id="end-handle"></div>
  </div>
  <div class="flex justify-between items-center mb-2">
    <div class="text-sm font-mono flex items-center">
      <span class="text-xs" id="start-block-value">
        0
      </span>
      <input type="hidden" name="start" id="start-block-input" value="0">
    </div>
    <div class="text-sm font-mono flex items-center">
      <span class="text-xs" id="end-block-value">∞</span>
      <input type="hidden" name="end" id="end-block-input" value="">
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const startHandle = document.getElementById('start-handle');
    const endHandle = document.getElementById('end-handle');
    const activeTrack = document.getElementById('active-track');
    const startBlockInput = document.getElementById('start-block-input');
    const endBlockInput = document.getElementById('end-block-input');
    const startBlockValue = document.getElementById('start-block-value');
    const endBlockValue = document.getElementById('end-block-value');
    const sliderContainer = startHandle.parentElement;
    const sliderRect = sliderContainer.getBoundingClientRect();
    const sliderWidth = sliderRect.width;

    // Set initial positions
    let startPos = 0;
    let endPos = sliderWidth;
    
    // Get initial values from URL params if they exist
    const urlParams = new URLSearchParams(window.location.search);
    const startParam = urlParams.get('start') || 0;
    const endParam = urlParams.get('end');

    var blockchainLength = undefined;
    fetch("/block_height").then(response => response.json()).then(data => {
      blockchainLength = data.block_height + 1;

      startBlockInput.value = startParam;
      startBlockValue.textContent = startParam;
      startPos = (parseInt(startParam) / blockchainLength) * sliderWidth;

      if (endParam !== null) {
        endBlockInput.value = endParam;
        endBlockValue.textContent = endParam;
        endPos = (parseInt(endParam) / blockchainLength) * sliderWidth;
      } else {
        endPos = sliderWidth;
        endBlockInput.value = "";
        endBlockValue.textContent = '∞';
      }
    });
    
    // Update positions
    updatePositions();
    
    // Handle dragging
    let isDragging = false;
    let currentHandle = null;
    
    function startDrag(e, handle) {
      isDragging = true;
      currentHandle = handle;
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', stopDrag);
      document.addEventListener('touchmove', drag);
      document.addEventListener('touchend', stopDrag);
    }
    
    function drag(e) {
      if (!isDragging) return;
      
      const sliderRect = sliderContainer.getBoundingClientRect();
      const sliderLeft = sliderRect.left;
      const sliderWidth = sliderRect.width;
      
      // Get position relative to slider
      let clientX = e.clientX;
      if (e.type === 'touchmove') {
        clientX = e.touches[0].clientX;
      }
      
      let newPos = clientX - sliderLeft;
      newPos = Math.max(0, Math.min(newPos, sliderWidth));
      
      // Update position and value
      if (currentHandle === startHandle) {
        if (newPos < endPos - 20) { // Prevent handles from crossing
          startPos = newPos;
          // Calculate block value (0 to ~800k)
          const blockValue = Math.round((newPos / sliderWidth) * blockchainLength);
          startBlockInput.value = blockValue;
          startBlockValue.textContent = blockValue;
          startBlockValue.classList.remove('hidden');
        }
      } else if (currentHandle === endHandle) {
        if (newPos > startPos + 20) { // Prevent handles from crossing
          endPos = newPos;
          // Calculate block value (0 to ~800k)
          const blockValue = Math.round((newPos / sliderWidth) * blockchainLength);
          endBlockInput.value = blockValue;
          endBlockValue.textContent = blockValue;
          endBlockValue.classList.remove('hidden');
        }
      }
      
      updatePositions();
      
      // Trigger form change event for htmx
      const event = new Event('change', { bubbles: true });
      startBlockInput.dispatchEvent(event);
    }
    
    function stopDrag() {
      isDragging = false;
      document.removeEventListener('mousemove', drag);
      document.removeEventListener('mouseup', stopDrag);
      document.removeEventListener('touchmove', drag);
      document.removeEventListener('touchend', stopDrag);
    }
    
    function updatePositions() {
      // Update handle positions
      startHandle.style.left = `${startPos}px`;
      endHandle.style.left = `${endPos}px`;
      
      // Update active track
      activeTrack.style.left = `${startPos}px`;
      activeTrack.style.width = `${endPos - startPos}px`;
    }
    
    startHandle.addEventListener('mousedown', function(e) {
      startDrag(e, startHandle);
    });
    
    endHandle.addEventListener('mousedown', function(e) {
      startDrag(e, endHandle);
    });
    
    // Touch support
    startHandle.addEventListener('touchstart', function(e) {
      e.preventDefault();
      startDrag(e, startHandle);
    });
    
    endHandle.addEventListener('touchstart', function(e) {
      e.preventDefault();
      startDrag(e, endHandle);
    });
  });
</script>
